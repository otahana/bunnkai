<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>分解ゲーム画面</title>
    <style>
        /* -------------------------------------- */
        /* CSSセクション */
        /* -------------------------------------- */

        body {
            margin: 0;
            height: 100vh;
            overflow: hidden; 
            background-image: url(title00.jpg);
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: url(title00.jpg); 
            background-size: cover;
            background-position: center;
            position: relative;
        }

        /* 非表示にするクラス */
        .hidden {
            display: none !important;
        }

        /* 1. 静的ヘッダーのスタイル (タイトル) */
        #static-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px 20px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            z-index: 50;
            box-shadow: 0 2px 5px #0000001a;
        }
        #game-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2a1510;
        }

        /* 2. スタートボタンのスタイル */
        #start-button {
            font-size: 3em;
            padding: 20px 40px;
            cursor: pointer;
            background-color: white;
            border: none;
            z-index: 20;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0), 
            inset 0 0 10px rgb(0, 217, 255);
            color: #2a151054;
        }

        /* 3. ゲーム画面コンテナのスタイル */
        #game-screen {
            width: 100%;
            height: 100%;
            position: relative;
            background-size: 70%;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* コマ撮りアニメーション領域のスタイル */
        #stop-motion-area {
            width: 70%; 
            height: 100%; 
            position: absolute;
            top: 0;
            left: 15%; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* コマ撮り画像 (アニメーション中に切り替わる要素) */
        #current-frame {
            width: 100%; 
            height: auto;
            object-fit: contain;
            z-index: 5;
        }

        /* 中央の大きなクリック領域 (トリガー) */
        #central-trigger {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 10;
        }

        /* タイトルに戻るボタンのスタイル */
        .clickable-area {
            position: absolute;
            cursor: pointer;
            display: flex; 
            justify-content: center;
            align-items: center;
            text-decoration: none;
            color: #2a1510b6;
            font-size: 1.5em;
            font-weight: bold;
            background-color: transparent;
            transition: background-color 0.3s;
            z-index: 25; 
        }

        .tiyle-area {
            width: 185px; 
            height: 60px; 
            top: 50px;      
            right: 20px;  
            left: 0px;     
            bottom: auto;   
        }

        .clickable-area:hover {
            background-color: rgba(235, 235, 235, 0.102);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0), inset 0 0 10px rgb(0, 217, 255);
        }

        /* コントロールボタンエリアのスタイル */
        #control-buttons {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            padding: 10px;
            z-index: 15;
        }
        #control-buttons button {
            padding: 10px 20px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0);
            color: #2a151054;
            margin: 0 5px;
            cursor: pointer;
            font-size: 1.1em;
            border: none;
            background-color: #ffffff;
            box-shadow: 0 2px 5px #0000001a;
            transition: box-shadow 0.3s, background-color 0.3s, transform 0.3s;
        }
        
        /* ★修正: 再生・逆再生ボタンにのみ黄色を適用 */
        /* prev-phase-buttonとnext-phase-button以外に適用 */
        #control-buttons button:not(#prev-phase-button):not(#next-phase-button) { 
            background-color: #ff863bd0; 
            color: #000;
        }

        /* ★追加: 前の分解へボタンのデフォルトスタイル（白に戻す）*/
        #prev-phase-button {
            background-color: #ffffff;
            color: #2a151054;
        }

        /* 無効化されたボタンのスタイル（分解開始時は無効になる） */
        #control-buttons button:disabled {
            background-color: #f0f0f0; 
            color: #aaa; 
            cursor: not-allowed;
            box-shadow: none;
        }

        /* 次へ進むボタンが光るスタイル */
        #control-buttons button.highlight {
            background-color: rgba(235, 235, 235, 0.102); 
            border-color: #00d9ff; 
            box-shadow: 0 0 10px rgba(255, 255, 255, 0), inset 0 0 10px #00d9ff;
            font-weight: bold;
            transform: none; 
            color: #2a1510; 
        }
    </style>
</head>
<body>
    
    <header id="static-header">
        <span id="game-title">おもちゃ＜ぜんまいカー＞</span>
    </header>

    <a href="MDA.html" class="clickable-area tiyle-area">タイトル</a>

    <button id="start-button">START</button>

    <div id="game-screen" class="hidden">
        
        <div id="stop-motion-area">
            <img id="current-frame" src="" alt="おもちゃの写真" style="display: none;">
            <div id="central-trigger" onclick="playCurrentPhase()"></div>
        </div>

        <div id="control-buttons" class="hidden">
            <button id="prev-phase-button" onclick="prevPhase()" disabled>前の分解へ</button>
            <button onclick="playCurrentPhase(1)">► 再生</button>
            <button onclick="playCurrentPhase(-1)">◄ 逆再生</button>
            <button id="next-phase-button" onclick="nextPhase()">次の分解へ</button>
        </div>
        
    </div>

    <script>

// --------------------------------------
// JavaScriptセクション (前回の修正から変更なし)
// --------------------------------------

const GIMMICK_PHASES = {
    'kaitenn': { frames: 9, path: 'img/kaitenn/kaitenn' },
    'taiyahazureru': { frames: 13, path: 'img/taiyahazureru/taiyahazureru' },
    'taiya': { frames: 13, path: 'img/taiya/taiya' }, 
    'bou': { frames: 12, path: 'img/bou/bou' },
    'hiraitewakareru': { frames: 8, path: 'img/hiraitewakareru/hiraitewakareru' },
    'ue': { frames: 18, path: 'img/ue/ue' },
    'sita': { frames: 25, path: 'img/sita/sita' },
    'mota': { frames: 8, path: 'img/mota/mota' }, 
    'modoru': { frames: 31, path: 'img/modoru/modoru' },
    'taisann': { frames: 9, path: 'img/taisann/taisann' }
};

let PHASE_ORDER = [
    'kaitenn',
    'taiyahazureru',
    'taiya',
    'bou',
    'hiraitewakareru',
    'mota',
    'modoru',
    'taisann'
];

const FRAME_DELAY = 100;

const CUSTOM_DELAYS = {
    'mota': 200, 
    'modoru': 200,
    'taisann': 200
};

let animationInterval;
let currentPhaseIndex = 0;
let currentFrameIndex = 0;
let currentDirection = 1;

let gameScreen;
let currentFrameImage;
let controlButtons;
let nextPhaseButton; 
let prevPhaseButton; 

document.addEventListener('DOMContentLoaded', () => {
    const startButton = document.getElementById('start-button');
    gameScreen = document.getElementById('game-screen');
    currentFrameImage = document.getElementById('current-frame');
    controlButtons = document.getElementById('control-buttons');
    nextPhaseButton = document.getElementById('next-phase-button'); 
    prevPhaseButton = document.getElementById('prev-phase-button'); 
    
    function startGame() {
        startButton.classList.add('hidden');
        gameScreen.classList.remove('hidden');
        controlButtons.classList.remove('hidden');
        loadInitialFrame();
    }

    function getFramePath(phaseName, index) {
        const phase = GIMMICK_PHASES[phaseName];
        if (!phase) {
            console.error(`Error: GIMMICK_PHASESに '${phaseName}' が見つかりません。`);
            return '';
        }
        const frameNum = index.toString().padStart(2, '0');
        return `${phase.path}${frameNum}.jpg`; 
    }

    function loadInitialFrame() {
        if (currentPhaseIndex >= PHASE_ORDER.length) return; 

        const phaseName = PHASE_ORDER[currentPhaseIndex];
        const initialPath = getFramePath(phaseName, 0);

        currentFrameImage.src = initialPath;
        currentFrameImage.style.display = 'none';
        gameScreen.style.backgroundImage = `url(${initialPath})`;
        currentFrameIndex = 0;
        stopStopMotion();
        nextPhaseButton.classList.remove('highlight'); 
        updateControlButtons();
    }
    
    window.playCurrentPhase = function(direction = 1) {
        if (animationInterval) return;

        const phaseName = PHASE_ORDER[currentPhaseIndex];
        const phase = GIMMICK_PHASES[phaseName];
        if (!phase) { console.error("無効なフェーズ名です:", phaseName); return; }

        currentDirection = direction;
        
        if (currentDirection === 1 && currentFrameIndex === phase.frames - 1) return;
        if (currentDirection === -1 && currentFrameIndex === 0) return;
        
        nextPhaseButton.classList.remove('highlight'); 

        gameScreen.style.backgroundImage = 'none'; 
        currentFrameImage.style.display = 'block';

        const delay = CUSTOM_DELAYS[phaseName] || FRAME_DELAY;
        
        animationInterval = setInterval(() => {
            currentFrameIndex += currentDirection;

            let animationFinished = false;
            let finalIndex = currentFrameIndex;

            if (currentFrameIndex < 0) {
                finalIndex = 0;
                animationFinished = true;
            } else if (currentFrameIndex >= phase.frames) {
                finalIndex = phase.frames - 1;
                animationFinished = true;
            }
            
            if (animationFinished) {
                currentFrameIndex = finalIndex;
                stopStopMotion();
                
                setTimeout(() => {
                    const finalPath = getFramePath(phaseName, finalIndex);
                    currentFrameImage.src = finalPath; 
                    currentFrameImage.style.display = 'none'; 
                    gameScreen.style.backgroundImage = `url(${finalPath})`;

                    if (currentDirection === 1) {
                        nextPhaseButton.classList.add('highlight');
                    }
                }, delay); 

            } else {
                currentFrameImage.src = getFramePath(phaseName, currentFrameIndex);
            }
        }, delay); 
    }
    
    window.stopStopMotion = function() {
        clearInterval(animationInterval);
        animationInterval = null;
    }

    // 前のギミックへ戻る
    window.prevPhase = function() {
        stopStopMotion();
        
        if (currentPhaseIndex > 0) {
            currentPhaseIndex--;
            loadInitialFrame();
        }
    }

    // 次のギミックへ進む
    window.nextPhase = function() {
        stopStopMotion();
        
        currentPhaseIndex++;

        if (currentPhaseIndex < PHASE_ORDER.length) {
            loadInitialFrame();
        } else {
            controlButtons.classList.add('hidden');
        }
    }
    
    // コントロールボタンの表示切り替え 
    function updateControlButtons() {
        // 最初のフェーズかどうかで「前の分解へ」ボタンを無効化する
        if (currentPhaseIndex === 0) {
            prevPhaseButton.disabled = true;
        } else {
            prevPhaseButton.disabled = false;
        }
    }

    // window.nextPhase の修正箇所
    window.nextPhase = function() {
    stopStopMotion();
    
    currentPhaseIndex++;

    if (currentPhaseIndex < PHASE_ORDER.length) {
        loadInitialFrame();
    } else {
        // ★修正: ギミック完了後、omotya.html に遷移する
        window.location.href = 'omotya.html'; 
        // alert("全てのギミックが完了しました！"); // alertは削除
        // controlButtons.classList.add('hidden'); // 非表示処理は不要になる
    }
}
    
    startButton.addEventListener('click', startGame);
    currentFrameImage.src = getFramePath('kaitenn', 0);
    updateControlButtons(); 
});
    </script>
</body>
</html>